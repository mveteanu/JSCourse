<script>

console.log( mod1(-5, 3) );
console.log( mod1(-13, 64) );
console.log( mod1(-1000, 3) );
console.log( mod1(-64,64) );
console.log( mod1(64,64) );

console.log("---")

console.log( mod2(-5, 3) );
console.log( mod2(-13, 64) );
console.log( mod2(-1000, 3) );
console.log( mod2(-64,64) );
console.log( mod2(64,64) );

console.log("---")

console.log( mod3(-5, 3) );
console.log( mod3(-13, 64) );
console.log( mod3(-1000, 3) );
console.log( mod3(-64,64) );
console.log( mod3(64,64) );

console.log("Equal: " + areEqual());

function areEqual()
{
    var equal = true;
    for(var n = -100; n <= 1000; n++)
    {
        for(var p=1; p <= 100; p++)
        {
            var m1 = mod1(n, p);
            var m2 = mod2(n, p);
            var m3 = mod3(n, p);

            if (m1!=m2 || m1!=m3 || m2!=m3)
            {
                console.log( n, p, m1, m2, m3 );
                equal = false;
            }
        }
    }

    return equal;
}

// Implement modulo by replacing the negative operand 
// with an equivalent positive operand that has the same wrap-around effect
function mod1(n, p)
{
    if ( n < 0 )
        n = p - Math.abs(n) % p;

    return n % p;
}

// Implement modulo by relying on the fact that the negative remainder
// is always p numbers away from a positive reminder
// Ex: -5 % 3 | -5 = -2 * 3 + 1 and -5 = -1 * 3 + (-2) | -2 + 3 = 1  
function mod2(n, p)
{
    var r = n % p;

    return r < 0 ? r + p : r;
}

// Implement modulo by solving n = v * p + r equation  
function mod3(n, p) 
{
    return n - p * Math.floor( n / p );
}

</script>
